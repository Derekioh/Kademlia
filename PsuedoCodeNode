****Main.cpp****

If 1 Command Line argument:
	Node(ID);
	//ASSERT: attempt to start a new network and create
	//        Routing Table for this node.
	
	if Node.joined():
		Node.startListener();
		//ASSERT: start continuous listeners for UI, other nodes,
		//        and refreshing nodes.
	else:
		Error out
else:
	Node(ID, contactTriple);
	//ASSERT: create Routing Table and place the contactTriple in it.
	//        Then send (FIND_NODE ID) to contactTriple to join the network.
	//        If it times-out, we failed to join the network.
	
	if Node.joined():
		Node.startListener();
		//ASSERT: start continuous listeners for UI, other nodes,
		//        and refreshing nodes.
	else:
		Error out
		
****Node****

Node(ID):
	Initialize Routing Table;
	create key vector;
	Join = true;

Node(ID, contactTriple):
	Initialize Routing Table;
	Add contactTriple to Routing Table;
	create key vector;
	Send (FIND_NODE ID) to contactTriple;
	Start Temp Listener on port 6667:
		recieve k closest message;
		if timed-out or run out of k closest to query:
			end listener;
	if timed-out:
		Joined = false;
	else:
		Joined = true;

startListener():
	create queue to refresh Nodes; //used for refresh thread
	
	startL1(refreshQueue);
	//ASSERT: a thread used for strictly dealing with UI.
	//        AKA UI commands such as FIND_VALUE and STORE.
	startL2(refreshQueue);
	//ASSERT: a thread used strictly for updating the routing
	//        table when we recieve a message from a node.
	//        We create this thread since we may have to ping
	//        the LRU node in a bucket if it full and that can
	//        take a variable amount of time.
	
	Listen on port 6666: //thread for responding to other nodes
		if there is a message, store in msg;
		if msg == PING:
			repsond with PING_RESP;
			push senderTriple to refreshQueue;
		if msg == STORE:
			push key to our keys list member data;
			push senderTriple to refreshQueue;
		if msg == FIND_NODE:
			respond with KCLOS;
			push senderTriple to refreshQueue;
		if msg == FIND_VALUE:
			if we have value:
				repsond with FIND_VALUE_RESP_TRUE;
			else:
				respond with KCLOS;
			push senderTriple to refreshQueue;
	
//NOTE: every time we send a message we send the port number we want
//      the reciever to respond on.
L1(refreshQueue *):
	create snapShot;
	init curMsg variable;
	create TimeoutQueue;
	
	Listen on port 6667:
		if there is a message, store in msg;
		push senderTriple to refreshQueue;
		if msg == FIND_VALUE_UI:
			if we have value:
				respond to UI with FIND_VALUE_RESP_TRUE;
			else:
				curMsg = FIND_VALUE;
				find our Kclos and store in our snapShot;
				for node in range(ALPHA) in snapShot that is not already queried:
					send FIND_VALUE to node
					push msg to TimeoutQueue;
		if msg == STORE_UI:
			curMsg = STORE_UI;
			find our Kclos and store in our snapShot;
			for node in range(ALPHA) in snapShot that is not already queried:
				send FIND_NODE to node;
				push msg to TimeoutQueue;
		if msg == KCLOS:
			remove msg from TimeoutQueue;
			update snapshot with this msg Kclos;
			if no more non queired nodes in snapShot:
				if curMsg == STORE_UI:
					for node in snapShot:
						send STORE to node;
					send UI the message STORE_UI_DONE;
				if curMsg == FIND_VALUE_UI:
					send UI the message FIND_VALUE_RESP_FALSE;
			else:
				if curMsg == STORE_UI:
					send FIND_NODE to next non queired node in snapShot;
				if curMsg == FIND_VALUE_UI:
					send FIND_VALUE to next non queired node in snapShot;
				push msg to TimeoutQueue;
		
		for msg in TimeoutQueue:
			if timed-out:
				remove from queue;
				remove reciever node from Routing Table;
				//TODO: more?
				
//NOTE: every time we send a message we send the port number we want
//      the reciever to respond on.
L2(refreshQueue *):
	create TimeoutQueue;
	init curNode to add variable;
	Listen on port 6668:
		if there is a message, store in msg;
		if refreshQueue no empty:
			pop triple from refreshQueue;
			bool added = updateTable(triple);
			if not added:
				//ASSERT: means it is not in the Routing table
				//        and the bucket is full
				send PING to LRU triple in the KBucket;
				curNode = triple;
				push msg to TimeoutQueue;
			
		
		for msg in TimeoutQueue:
			if timed-out:
				remove from queue;
				remove reciever node from Routing Table;
				updateTable(curNode);
				//TODO: more?